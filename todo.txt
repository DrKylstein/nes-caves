 18  bytes left in page $000
 163  bytes left for copy buffer
 32  bytes left for stack
 20  sprites left in upper table
 125 bytes left in pages $300-$700
 PRGROM Bank 0 left: 898
 PRGROM Bank 1 left: 87
 PRGROM Bank 2 left: 4096
 PRGROM Bank 3 left: 3660
 PRGROM Bank 4 left: 16384
 PRGROM Bank 5 left: 16384
 PRGROM Bank 6 left: 16384
 PRGROM Bank 7 left: 3181
 
must:
slime direction change is poor
level 13
-low gravity - no change to jump height [not sure about fall speed?], but gun recoil, about 8px in l14, 24-32px in l13
fix: narrow switch collision changes level 14 dynamic
jump feels too floaty vs og
add ending image
push out of wall when on horizontal platform
add hidden crystals
did I forget that chests vary in points? probably, because I still don't know how or why.
eyemonster blink pattern doesn't seem right
more sounds
-power ups
-chests
-bullet impacts
-flames
-getting hit
-popup messages
-enemy shots
fix corrpution/bad collision in left side of level

optimizations:
condense faucet into one entity - it doesn't drip if the player is above, 
 which is the most likely case for when it could fall offscreen.
delete entity speeds table
delete entity initial anim table
store size and shared offset instead of individual offsets in frames?
-faster? denser, can re-use y coordinate on horizontal runs
convert most player variables to entity variables, move player code to player entity?
use tile type to find door/exit positions? (store as 16-bit pointers) would save 3 bytes per door/exit
disable tile animation in other levels? (move to an entity or use level number?)

long shot:
enter animation
implement trike (can't kill eye creature in that space, ball takes fewer hits)
add walker? (different attack from robot)
add floating alien wrench? uses walking collision, unlike bat
shoot/just fired animation
double up channels so that long notes can resume after very short ones
music
enemy hit flash

for sequel/level pack:
fix: eyemonster walks partially inside walls, can push left eye into negative x

-----------------------------
Alternative entity storage
ROM:
-index to initialization routine ;1*Stored*Levels
-initial tile (x,y) ;2*Stored*Levels
RAM:
for all entities:
-latest tile (x,y) (some null value for dead or uninitialized?) ;2xMax
-index to active entity fields, or null ;1xMax
for active entities:
-sub-tile and? sub-pixel coords? 4.4 ;2xActive
-current routine ptr ;2xActive
-velocity 4.4 x and y ;2xActive
-variables ;2xActive (external physics, so can't reuse velocity, so count+velocity's worth)
-animation index ;1xActive
-frame counter ;1xActive

3xStoredxLevels
3xMax + 10xActive

30 max, 10 active: 90+100 = 190
30 fixed, current (x8) fields: 240
50 saved
save > 1.6 per max entity

[don't! would have to iterate either way, just check for null pointers]use bitmap to track usage of active fields (8 active or 16 active)

32 max, 8 active: 96+80 = 176
32 fixed: 256
80 saved
save 2.5 per entity
break even at 16 active

262v272 for 16/34 vs fixed

mini:
tile x,y, fixed routine index
--
tile x,y 2x
active index 1x
3x
--
fine x,y 2x
x/y velocity 8.0 1x
count 1x
anim 1x
frame 1x
6x

198v272 for 16/34 (-74)